#!/usr/bin/env ruby

require 'pp'
require 'zlib'

# Borrows heavily from https://github.com/Backblaze/JavaReedSolomon.
# https://github.com/Backblaze/JavaReedSolomon/blob/0e7f3c84350b416bf1431215929241c6d82f03fe/src/main/java/com/backblaze/erasure/Galois.java
# https://github.com/Backblaze/JavaReedSolomon/blob/0e7f3c84350b416bf1431215929241c6d82f03fe/src/main/java/com/backblaze/erasure/Matrix.java

# Mapping from members of the Galois Field to their
# integer logarithms.  The entry for 0 is meaningless
# because there is no log of 0.
#
# This array is shorts, not bytes, so that they can
# be used directly to index arrays without casting.
# The values (except the non-value at index 0) are
# all really bytes, so they range from 0 to 255.
#
# This table was generated by java_tables.py, and the
# unit tests check it against the Java implementation.

LOG_TABLE = [
   -1,    0,    1,   25,    2,   50,   26,  198,
    3,  223,   51,  238,   27,  104,  199,   75,
    4,  100,  224,   14,   52,  141,  239,  129,
   28,  193,  105,  248,  200,    8,   76,  113,
    5,  138,  101,   47,  225,   36,   15,   33,
   53,  147,  142,  218,  240,   18,  130,   69,
   29,  181,  194,  125,  106,   39,  249,  185,
  201,  154,    9,  120,   77,  228,  114,  166,
    6,  191,  139,   98,  102,  221,   48,  253,
  226,  152,   37,  179,   16,  145,   34,  136,
   54,  208,  148,  206,  143,  150,  219,  189,
  241,  210,   19,   92,  131,   56,   70,   64,
   30,   66,  182,  163,  195,   72,  126,  110,
  107,   58,   40,   84,  250,  133,  186,   61,
  202,   94,  155,  159,   10,   21,  121,   43,
   78,  212,  229,  172,  115,  243,  167,   87,
    7,  112,  192,  247,  140,  128,   99,   13,
  103,   74,  222,  237,   49,  197,  254,   24,
  227,  165,  153,  119,   38,  184,  180,  124,
   17,   68,  146,  217,   35,   32,  137,   46,
   55,   63,  209,   91,  149,  188,  207,  205,
  144,  135,  151,  178,  220,  252,  190,   97,
  242,   86,  211,  171,   20,   42,   93,  158,
  132,   60,   57,   83,   71,  109,   65,  162,
   31,   45,   67,  216,  183,  123,  164,  118,
  196,   23,   73,  236,  127,   12,  111,  246,
  108,  161,   59,   82,   41,  157,   85,  170,
  251,   96,  134,  177,  187,  204,   62,   90,
  203,   89,   95,  176,  156,  169,  160,   81,
   11,  245,   22,  235,  122,  117,   44,  215,
   79,  174,  213,  233,  230,  231,  173,  232,
  116,  214,  244,  234,  168,   80,   88,  175
]

# Inverse of the logarithm table.  Maps integer logarithms
# to members of the field.  There is no entry for 255
# because the highest log is 254.
#
# This table was generated by java_tables.py.

EXP_TABLE = [
     1,    2,    4,    8,   16,   32,   64, -128,
    29,   58,  116,  -24,  -51, -121,   19,   38,
    76, -104,   45,   90,  -76,  117,  -22,  -55,
  -113,    3,    6,   12,   24,   48,   96,  -64,
   -99,   39,   78, -100,   37,   74, -108,   53,
   106,  -44,  -75,  119,  -18,  -63,  -97,   35,
    70, -116,    5,   10,   20,   40,   80,  -96,
    93,  -70,  105,  -46,  -71,  111,  -34,  -95,
    95,  -66,   97,  -62, -103,   47,   94,  -68,
   101,  -54, -119,   15,   30,   60,  120,  -16,
    -3,  -25,  -45,  -69,  107,  -42,  -79,  127,
    -2,  -31,  -33,  -93,   91,  -74,  113,  -30,
   -39,  -81,   67, -122,   17,   34,   68, -120,
    13,   26,   52,  104,  -48,  -67,  103,  -50,
  -127,   31,   62,  124,   -8,  -19,  -57, -109,
    59,  118,  -20,  -59, -105,   51,  102,  -52,
  -123,   23,   46,   92,  -72,  109,  -38,  -87,
    79,  -98,   33,   66, -124,   21,   42,   84,
   -88,   77, -102,   41,   82,  -92,   85,  -86,
    73, -110,   57,  114,  -28,  -43,  -73,  115,
   -26,  -47,  -65,   99,  -58, -111,   63,  126,
    -4,  -27,  -41,  -77,  123,  -10,  -15,   -1,
   -29,  -37,  -85,   75, -106,   49,   98,  -60,
  -107,   55,  110,  -36,  -91,   87,  -82,   65,
  -126,   25,   50,  100,  -56, -115,    7,   14,
    28,   56,  112,  -32,  -35,  -89,   83,  -90,
    81,  -94,   89,  -78,  121,  -14,   -7,  -17,
   -61, -101,   43,   86,  -84,   69, -118,    9,
    18,   36,   72, -112,   61,  122,  -12,  -11,
    -9,  -13,   -5,  -21,  -53, -117,   11,   22,
    44,   88,  -80,  125,   -6,  -23,  -49, -125,
    27,   54,  108,  -40,  -83,   71, -114,
  # Repeat the table a second time, so multiply()
  # does not have to check bounds.
     1,    2,    4,    8,   16,   32,   64, -128,
    29,   58,  116,  -24,  -51, -121,   19,   38,
    76, -104,   45,   90,  -76,  117,  -22,  -55,
  -113,    3,    6,   12,   24,   48,   96,  -64,
   -99,   39,   78, -100,   37,   74, -108,   53,
   106,  -44,  -75,  119,  -18,  -63,  -97,   35,
    70, -116,    5,   10,   20,   40,   80,  -96,
    93,  -70,  105,  -46,  -71,  111,  -34,  -95,
    95,  -66,   97,  -62, -103,   47,   94,  -68,
   101,  -54, -119,   15,   30,   60,  120,  -16,
    -3,  -25,  -45,  -69,  107,  -42,  -79,  127,
    -2,  -31,  -33,  -93,   91,  -74,  113,  -30,
   -39,  -81,   67, -122,   17,   34,   68, -120,
    13,   26,   52,  104,  -48,  -67,  103,  -50,
  -127,   31,   62,  124,   -8,  -19,  -57, -109,
    59,  118,  -20,  -59, -105,   51,  102,  -52,
  -123,   23,   46,   92,  -72,  109,  -38,  -87,
    79,  -98,   33,   66, -124,   21,   42,   84,
   -88,   77, -102,   41,   82,  -92,   85,  -86,
    73, -110,   57,  114,  -28,  -43,  -73,  115,
   -26,  -47,  -65,   99,  -58, -111,   63,  126,
    -4,  -27,  -41,  -77,  123,  -10,  -15,   -1,
   -29,  -37,  -85,   75, -106,   49,   98,  -60,
  -107,   55,  110,  -36,  -91,   87,  -82,   65,
  -126,   25,   50,  100,  -56, -115,    7,   14,
    28,   56,  112,  -32,  -35,  -89,   83,  -90,
    81,  -94,   89,  -78,  121,  -14,   -7,  -17,
   -61, -101,   43,   86,  -84,   69, -118,    9,
    18,   36,   72, -112,   61,  122,  -12,  -11,
    -9,  -13,   -5,  -21,  -53, -117,   11,   22,
    44,   88,  -80,  125,   -6,  -23,  -49, -125,
    27,   54,  108,  -40,  -83,   71, -114
]

# Multiplies two elements of the field.
def gf2_element_times(a, b)
  if (a == 0 || b == 0)
    return 0
  else
    logA = LOG_TABLE[a & 0xFF]
    logB = LOG_TABLE[b & 0xFF]
    logResult = logA + logB
    return EXP_TABLE[logResult]
  end
end

# Multiplies two matrices.
def gf2_matrix_times(magic, data)
  result = Array.new(magic.count){Array.new(data[0].count)}
  magic.each_index do |r|
    data[0].each_index do |c|
      value = 0
      (magic[0]).each_index do |i|
        value ^= gf2_element_times(magic[r][i], data[i][c])
      end
      result[r][c] = value
    end
  end
  result
end

def mcrc(matrix)
  Zlib.crc32(Marshal.dump(matrix)).to_s(16).rjust(8, '0')
end

def mpp(matrix, header)
  puts "# #{header}"
  puts "    # #{mcrc(matrix)}"
  p = PP.pp(matrix, "", 30)
  p.each_line do |l|
    print "    ".concat(l)
  end
  puts
end

h='Original data.'
data = [
  ["A".ord,"B".ord,"C".ord,"D".ord],
  ["E".ord,"F".ord,"G".ord,"H".ord],
  ["I".ord,"J".ord,"K".ord,"L".ord],
  ["M".ord,"N".ord,"O".ord,"P".ord],
]

mpp data, h

h='Magic matrix to create 2 parity blocks.'
magic_create = [
  [1,0,0,0],
  [0,1,0,0],
  [0,0,1,0],
  [0,0,0,1],
  [0x1b,0x1c,0x12,0x14],
  [0x1c,0x1b,0x14,0x12],
]

mpp magic_create, h

h='Magic matrix to repair up to 2 missing blocks.'
magic_repair = [
  [1,0,0,0],
  [0,1,0,0],
  [0,0,1,0],
  [0,0,0,1],
  [0x8d,0xf6,0x7b,0x01],
  [0xf6,0x8d,0x01,0x7b],
]

mpp magic_repair, h

h='Original data with 2 parity blocks appended.'
data_with_parity = gf2_matrix_times(magic_create, data)
mpp data_with_parity, h

h='Damaged data with 2 parity blocks appended and 2 data blocks missing.'
data_with_parity_and_damage = Marshal.load(Marshal.dump(data_with_parity))
data_with_parity_and_damage.delete_at(3)
data_with_parity_and_damage.delete_at(2)
mpp data_with_parity_and_damage, h

h='Magic matrix to repair damage (corresponding rows to the damaged blocks have been removed).'
magic_repair_to_match_damage = Marshal.load(Marshal.dump(magic_repair))
magic_repair_to_match_damage.delete_at(3)
magic_repair_to_match_damage.delete_at(2)
mpp magic_repair_to_match_damage, h

h='Repaired data.'
repaired_data = gf2_matrix_times(magic_repair_to_match_damage, data_with_parity_and_damage)
mpp repaired_data, h

puts "Original data marshaled matrix crc32: #{mcrc(data)}"
puts "Repaired data marshaled matrix crc32: #{mcrc(repaired_data)}"
